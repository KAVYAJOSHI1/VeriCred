const axios = require('axios');
const hre = require('hardhat');

async function main() {
    console.log("ðŸš€ Starting End-to-End Verification...");

    // 1. Generate Proof (Backend)
    const formData = {
        age: 30,
        income: 50000,
        debt: 2000,
        history: 5,
        open_acc: 3
    };

    console.log("\nðŸ“¡ Requesting Proof from Backend...");
    let proof, publicInstances;
    try {
        const response = await axios.post('http://localhost:8000/generate-proof', formData);
        proof = response.data.proof;
        publicInstances = response.data.public_instances;
        console.log("âœ… Proof Generated successfully!");
        console.log("   Proof Length:", proof.length);
        console.log("   Public Instances:", publicInstances);
    } catch (error) {
        console.error("âŒ Backend Error:", error.response ? error.response.data : error.message);
        process.exit(1);
    }

    // 2. Verify on Blockchain (Hardhat)
    console.log("\nâ›“ï¸  Verifying on Local Blockchain...");

    // Address from CreditScoreForm.tsx
    const VERIFIER_ADDRESS = '0x5FbDB2315678afecb367f032d93F642f64180aa3';

    try {
        const Verifier = await hre.ethers.getContractFactory("Halo2Verifier");
        const verifier = Verifier.attach(VERIFIER_ADDRESS);

        // Convert proof to bytes if it's a hex string (ethers handles 0x prefix)
        // Ensure it has 0x prefix
        const formattedProof = proof.startsWith('0x') ? proof : '0x' + proof;

        console.log(`   Calling verifyProof on contract at ${VERIFIER_ADDRESS}...`);

        // This is a view function or transaction? Usually verifyProof is a view or transaction.
        // If it's a pure/view function it returns bool. If it's a transaction, we check for revert.
        // Based on typical Halo2 Verifiers, it might revert on failure or return bool.
        // Let's try staticCall first to simulate.

        // Note: publicInstances from EZKL are usually fields. The contract expects uint256[] usually.
        // If data.public_instances is [0.5], we need to match how the contract expects it (quantized?).
        // Wait, the backend returns formatted public instances? 
        // Let's verify what the backend returns.

        // If the contract is standard Halo2Verifier generated by EZKL, it might take (proof, instances).
        try {
            // Static call to check result without mining
            const result = await verifier.verifyProof.staticCall(formattedProof, publicInstances);
            console.log("   Static Call Result:", result);

            if (result === true) {
                console.log("âœ… ON-CHAIN VERIFICATION PASSED (Static Call)");
            } else {
                console.error("âŒ ON-CHAIN VERIFICATION FAILED (Static Call returned false)");
            }
        } catch (e) {
            // If static call fails/reverts
            console.log("   Static call reverted (likely invalid proof/input). Attempting tx for error details...");
            try {
                const tx = await verifier.verifyProof(formattedProof, publicInstances);
                await tx.wait();
                console.log("âœ… ON-CHAIN VERIFICATION PASSED (Transaction Mined)");
            } catch (txError) {
                console.error("âŒ ON-CHAIN VERIFICATION FAILED (Transaction Reverted)");
                // console.error(txError);
            }
        }

    } catch (error) {
        console.error("âŒ Blockchain Error:", error);
        process.exit(1);
    }
}

main().catch((error) => {
    console.error(error);
    process.exitCode = 1;
});
